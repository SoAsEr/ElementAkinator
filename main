
from random import randint
# Define constants
#if 0, converges as quickly as possible
AVGNUMBEROFQUESTIONS = 0
# describes block of periodic table
periodicShapePeriod = ([1] * 2) + ([2] * 8) + \
    ([3] * 8) + ([4] * 18) + ([5] * 18)
periodicShapeFamily = [
    1, 18] + (([1, 2] + list(range(13, 19))) * 2) + (list(range(1, 19)) * 2)
# first I need to define the names (numbers (row, period))
elementNames = ["Hydrogen", "Helium", "Lithium", "Beryllium"]
elementNames += ["Boron", "Carbon", "Nitrogen", "Oxygen", "Fluorine", "Neon", "Sodium", "Magnesium", "Aluminum", "Silicon",
                 "Phosphorus", "Sulfur", "Chlorine", "Argon", "Potassium", "Calcium", "Scandium", "Titanium", "Vanadium", "Chromium"]
elementNames += ["Manganese", "Iron", "Cobalt", "Nickel", "Copper", "Zinc", "Gallium", "Germanium", "Arsenic", "Selenium", "Bromine", "Krypton",
                 "Rubidium", "Strontium", "Yttrium", "Zirconium", "Niobium", "Molybdenum", "Technetium", "Ruthenium", "Rhodium", "Palladium", "Silver"]
elementNames += ["Cadmium", "Indium", "Tin",
                 "Antimony", "Tellurium", "Iodine", "Xenon"]
'''
,"Cesium","Barium","Lanthanum","Cerium","Praseodymium","Neodymium","Promethium","Samarium","Europium","Gadolinium"]
elementNames+=["Terbium","Dysprosium","Holmium","Erbium","Thulium","Ytterbium","Lutetium","Hafnium","Tantalum","Tungsten","Rhenium","Osmium","Iridium","Platinum","Gold","Mercury","Thallium","Lead","Bismuth","Polonium","Astatine","Radon","Francium","Radium"]
elementNames+=["Actinium","Thorium","Protactinium","Uranium","Neptunium","Plutonium","Americium","Curium","Berkelium","Californium","Einsteinium","Fermium","Mendelevium","Nobelium","Lawrencium","Rutherfordium","Dubnium","Seaborgium","Bohrium","Hassium","Meitnerium","Darmstadtium","Roentgenium","Ununbium"]
elementNames+=["Ununtrium","Ununquadium","Ununpentium","Ununhexium","Ununseptium","Ununoctium"]
'''


def atomicNumberToElectronConfig(i):
    electronConfig = ""
    if(i == 1):
        electronConfig = "1s1"
        return electronConfig
    else:
        electronConfig = "1s"
    currentPeriod = 2
    currentFamily = 1
    runningBlockCounter = 1
    currentBlock = ""
    j = 2
    while(j < i):
        if(currentFamily == 1):
            electronConfig += str(runningBlockCounter + 1) + " "
            runningBlockCounter = 0
            electronConfig += str(currentPeriod) + "s"
        elif (currentFamily == 3):
            electronConfig += str(runningBlockCounter + 1) + " "
            runningBlockCounter = 0
            electronConfig += str(currentPeriod - 1) + "d"
        elif (currentFamily == 13):
            electronConfig += str(runningBlockCounter + 1) + " "
            runningBlockCounter = 0
            electronConfig += str(currentPeriod) + "p"
        else:
            runningBlockCounter += 1
        j += 1
        if(j < len(elementNames)):
            currentPeriod = periodicShapePeriod[j]
            currentFamily = periodicShapeFamily[j]
    if(currentFamily-1 == 6):
        electronConfig = electronConfig[:-6]
        electronConfig += str(currentPeriod) + "s1 " + \
            str(currentPeriod - 1) + "d5 "
    elif(currentFamily-1 == 11):
        electronConfig = electronConfig[:-6]
        electronConfig += str(currentPeriod) + "s1 " + \
            str(currentPeriod - 1) + "d10 "
    else:
        electronConfig += str(runningBlockCounter + 1) + " "
    return electronConfig


def eliminate(remainingElementDictionaries, field, questionParam, condition):
    newDic = remainingElementDictionaries.copy()
    for i in range(0, len(remainingElementDictionaries)):

        if((str(questionParam) in str(remainingElementDictionaries[i][field]))!=condition):
            for j in range(0, len(newDic)):
                if(newDic[j]["name"] == remainingElementDictionaries[i]["name"]):
                    newDic.pop(j)
                    break
    return newDic

#hell yeah, copy pasted quicksort code

def partition(arr,low,high):
    i = ( low-1 )         # index of smaller element
    pivot = arr[high][2]     # pivot

    for j in range(low , high):

        # If current element is smaller than or
        # equal to pivot
        if   arr[j][2] <= pivot:

            # increment index of smaller element
            i = i+1
            arr[i],arr[j] = arr[j],arr[i]

    arr[i+1],arr[high] = arr[high],arr[i+1]
    return ( i+1 )

# The main function that implements QuickSort
# arr[] --> Array to be sorted,
# low  --> Starting index,
# high  --> Ending index

# Function to do Quick sort
def quickSort(arr,low,high):
    if low < high:

        # pi is partitioning index, arr[p] is now
        # at right place
        pi = partition(arr,low,high)

        # Separately sort elements before
        # partition and after partition
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)


def getIdealQuestion(questionsLeft, remainingElementDictionaries):
    electronConfigPossibilites = []
    for i in range(1, 6):
        for j in range(1, 3):
            electronConfigPossibilites += [[str(i) + "s" + str(j)+ " ", 0]]
        if(2 <= i):
            for j in range(1, 7):
                electronConfigPossibilites += [[str(i) + "p" + str(j)+ " ", 0]]
        if(3 <= i <= 4):
            for j in range(1, 11):
                electronConfigPossibilites += [[str(i) + "d" + str(j)+ " ", 0]]
    possibleQuestions = []
    numOfExceptions = 0
    family = [0 for i in range(18)]
    period = [0 for i in range(5)]
    for i in range(0, len(remainingElementDictionaries)):
        possibleQuestions += [["name",
                               remainingElementDictionaries[i]["name"], 1]]
        if(remainingElementDictionaries[i]["exceptionToConfigRules"]):
            numOfExceptions += 1
        family[remainingElementDictionaries[i]["family"] - 1] += 1
        period[remainingElementDictionaries[i]["period"] - 1] += 1
        for j in range(0, len(electronConfigPossibilites)):
            if((electronConfigPossibilites[j][0]) in remainingElementDictionaries[i]["electronConfig"]):
                electronConfigPossibilites[j][1] += 1


    #no zero check because info gain below takes care of it and it's more readable this way
    possibleQuestions += [["exceptionToConfigRules", True, numOfExceptions]]
    for i in range(0, 18):
        possibleQuestions += [["family", i + 1, family[i]]]

    for i in range(0, 5):
        possibleQuestions += [["period", i + 1, period[i]]]

    for i in range(0, len(electronConfigPossibilites)):
        possibleQuestions += [["electronConfig", electronConfigPossibilites[i][0], electronConfigPossibilites[i][1]]]

    #turn number of positives into average element elimination
    for i in range(0, len(possibleQuestions)):
        posAnswerProb=float(possibleQuestions[i][2])/len(remainingElementDictionaries)
        negAnswerProb=1-posAnswerProb
        posAnswerNumberOfEliminatedResponses=len(remainingElementDictionaries)-possibleQuestions[i][2]
        negAnswerNumberOfEliminatedResponses=possibleQuestions[i][2]
        averageEliminatedResponses=(posAnswerProb*posAnswerNumberOfEliminatedResponses)+(negAnswerProb*negAnswerNumberOfEliminatedResponses)
        possibleQuestions[i][2]=averageEliminatedResponses
    i2=0
    while(i2<len(possibleQuestions)):
        if(possibleQuestions[i2][2]==0):
            possibleQuestions.pop(i2)
        else:
            i2+=1

    quickSort(possibleQuestions, 0, len(possibleQuestions)-1)
    if(questionsLeft>1):
        idealQuestionNumber=len(remainingElementDictionaries)*pow(1/len(remainingElementDictionaries), 1/questionsLeft)
        bestValueIndex=0
        for i in range(0, len(possibleQuestions)):
            if(possibleQuestions[i][2]>idealQuestionNumber):
                if(abs(possibleQuestions[i][2]-idealQuestionNumber)<abs(possibleQuestions[i-1][2]-idealQuestionNumber)):
                    bestValueIndex=i
                else:
                    bestValueIndex=i-1
                break
        allWithBestValue=[possibleQuestions[bestValueIndex]]
        for i in range(0, bestValueIndex):
            if(possibleQuestions[i][2]==possibleQuestions[bestValueIndex][2]):
                allWithBestValue+=[possibleQuestions[i]]
        result=allWithBestValue[randint(0, len(allWithBestValue)-1)]
        return result[0], result[1]
    else:
        return possibleQuestions[len(possibleQuestions)-1][0], possibleQuestions[len(possibleQuestions)-1][1]




def getQuestion(category, param):
    if(category=="name"):
        return "Is your element "+str(param)+"?"
    if(category=="exceptionToConfigRules"):
        return "Is your element an exception to the normal electron configuration rules?"
    if(category=="electronConfig"):
        return "Does your element contain "+str(param)+" in it's electron configuration"
    if(category=="family"):
        return "Is your element in family "+str(param)
    if(category=="period"):
        return "Is your element in period "+str(param)
    if(category=="atomicNumber
":
        return "Does your element's atomic number contain a "+str(param)

def main():
    numOfQuestionsAsked = 0
    remainingElementDictionaries = []
    for i in range(0, len(elementNames)):
        tempDic = {
            "name": elementNames[i],
            "electronConfig": atomicNumberToElectronConfig(i+1),
            "exceptionToConfigRules": (periodicShapeFamily[i] == 6 or periodicShapeFamily[i] == 11),
            "transitionMetal": (periodicShapeFamily[i] in list(range(3, 13))),
            "atomicNumber": str(i),
            "family": periodicShapeFamily[i],
            "period": periodicShapePeriod[i]
        }
        if(i==1):
            tempDic["family"]=18
        remainingElementDictionaries.append(tempDic)

    # from the numbers I determine electron configuration, hardcoding exceptions for half and fully filled D
    #"Is your element a metal?"
    #"Is your element a transition metal?"

    #"Does your element have _____ in it's electron configuration"

    #electronConfStrings=["Does your element have ", "in it's electron configuration"]
    #"Is your element an exception to the electron configuration rules?"
    #"Does your element form a charge of ___"
    #"Is you element's atomic number over ____"
    print("Is your element a transition metal? y/n")
    numOfQuestionsAsked += 1
    remainingElementDictionaries = eliminate(
        remainingElementDictionaries, "transitionMetal", True, input() == "y")

    while(len(remainingElementDictionaries) > 1):
        print()
        print("Possible Elements:")
        for i in range(0, len(remainingElementDictionaries)-1):
            print(remainingElementDictionaries[i]["name"], end=', ')
        print(remainingElementDictionaries[len(remainingElementDictionaries)-1]["name"])
        print()
        questionCategory, questionParam = getIdealQuestion(
            AVGNUMBEROFQUESTIONS - numOfQuestionsAsked, remainingElementDictionaries)
        print(getQuestion(questionCategory, questionParam)+ " y/n")
        remainingElementDictionaries = eliminate(
            remainingElementDictionaries, questionCategory, questionParam, input() == "y")
    print("Your element is: "+remainingElementDictionaries[0]["name"])
main()
